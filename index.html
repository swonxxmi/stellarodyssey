<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>战斗与加点模拟器</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .form-group { margin-bottom: 10px; }
        label { display: inline-block; width: 150px; }
        input[type="number"] { width: 100px; }
        #result { margin-top: 20px; padding: 10px; border: 1px solid #ccc; white-space: pre-wrap; }
        h2 { margin-top: 20px; }
        #progressContainer { margin-top: 10px; display: none; }
        #totalPointsWarning { color: red; display: none; }
        table { border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 8px; text-align: center; border: 1px solid #ccc; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <div style="display: flex;">
        <div style="flex: 1; margin-right: 20px;">
            <h2>克隆人装备与属性</h2>
            <div class="form-group">
                <label>数量:</label>
                <input type="number" id="cloneCount" value="1" oninput="updateCloneStats()">
            </div>
            <div class="form-group">
                <label>武器伤害:</label>
                <input type="number" id="baseCloneAttack" value="70" oninput="updateCloneStats()">
            </div>
            <div class="form-group">
                <label>护盾防御:</label>
                <input type="number" id="baseCloneHP" value="800" oninput="updateCloneStats()">
            </div>
            <div class="form-group">
                <label>暴击几率 (%):</label>
                <input type="number" id="critChance" value="0" step="0.1">
            </div>
            <div class="form-group">
                <label>暴击伤害 (%):</label>
                <input type="number" id="critDamage" value="130" step="0.1">
            </div>
            <div class="form-group">
                <label>双重射击 (%):</label>
                <input type="number" id="reAttackChance" value="0" step="0.1">
            </div>

            <h2>统计数据分配</h2>
            <div class="form-group">
                <label>能量加点 (A):</label>
                <input type="number" id="addAttack" value="10" min="0"  oninput="updateCloneStats()">
            </div>
            <div class="form-group">
                <label>精准加点 (C):</label>
                <input type="number" id="addPrecision" value="10" min="0"  oninput="updateCloneStats()">
            </div>
            <div class="form-group">
                <label>闪避加点 (D):</label>
                <input type="number" id="addDodge" value="10" min="0"  oninput="updateCloneStats()">
            </div>
            <div class="form-group">
                <label>装甲加点 (B):</label>
                <input type="number" id="addArmor" value="10" min="0"  oninput="updateCloneStats()">
            </div>
            <div class="form-group">
                <label>加点总和:</label>
                <span id="totalPoints">0</span>
                <span id="totalPointsWarning">加点总和发生变化！当前总点数：<span id="totalPointsValue">0</span></span>
            </div>
            <button type="button" onclick="resetToAverage()">平均分配</button>

            <h2>克隆人综合统计数据</h2>
            <div class="form-group">
                <label>玩家生命值:</label>
                <span id="cloneHP">800</span>
            </div>
            <div class="form-group">
                <label>玩家伤害:</label>
                <span id="cloneAttack">7</span>
            </div>
            <div class="form-group">
                <label>精准:</label>
                <span id="clonePrecision">2</span>
            </div>
            <div class="form-group">
                <label>闪避:</label>
                <span id="cloneDodge">2</span>
            </div>
        </div>

        <div style="flex: 1;">
            <h2>敌人参数</h2>
            <div class="form-group">
                <label>敌人等级:</label>
                <input type="number" id="enemyLevel" value="1" min="1" oninput="updateEnemyStats()">
            </div>
            <div class="form-group">
                <label>模组伤害加成:</label>
                <input type="number" id="damageMultiplier" value="1" step="0.15" oninput="updateEnemyStats()">
            </div>
            <div class="form-group">
                <label>生命值:</label>
                <span id="enemyHP">0</span>
            </div>
            <div class="form-group">
                <label>攻击力:</label>
                <span id="enemyAttack">0</span>
            </div>
            <div class="form-group">
                <label>精准:</label>
                <span id="enemyPrecision">0</span>
            </div>
            <div class="form-group">
                <label>闪避:</label>
                <span id="enemyDodge">0</span>
            </div>

            <h2>模拟设置</h2>
            <div class="form-group">
                <label>批量模拟次数:</label>
                <input type="number" id="simCount" value="36000" min="1">
            </div>

            
            <div class="form-group">
                <label>修改范围:</label>
                <input type="number" id="modifyRange" value="17" min="1">
            </div>
            <div class="form-group">
                <label>步长:</label>
                <input type="number" id="stepSize" value="1" min="1">
            </div>

            <button type="button" onclick="simulateBattle()">模拟单次战斗</button>
            <button type="button" onclick="batchSimulate()">批量模拟当前加点</button>
            <button type="button" onclick="findBestBuild()">寻找最优加点</button>

            <div id="progressContainer"> 
                <progress id="progressBar" value="0" max="100"></progress>
                <span id="progressText">0%</span>
            </div>
            <div id="result"></div>
        </div>
    </div>

    <script>
        let cloneStatsCache = {}; // 缓存克隆人统计数据

        // 页面加载时恢复输入值
        window.onload = function() {
            const elements = {
                enemyLevel: document.getElementById('enemyLevel'),
                damageMultiplier: document.getElementById('damageMultiplier'),
                cloneCount: document.getElementById('cloneCount'),
                baseCloneHP: document.getElementById('baseCloneHP'),
                baseCloneAttack: document.getElementById('baseCloneAttack'),
                critChance: document.getElementById('critChance'),
                critDamage: document.getElementById('critDamage'),
                reAttackChance: document.getElementById('reAttackChance'),
                addAttack: document.getElementById('addAttack'),
                addPrecision: document.getElementById('addPrecision'),
                addDodge: document.getElementById('addDodge'),
                addArmor: document.getElementById('addArmor'),
                simCount: document.getElementById('simCount'),
                modifyRange: document.getElementById('modifyRange'),
                stepSize: document.getElementById('stepSize'),
                totalPointsValue: document.getElementById('totalPointsValue'),
                totalPointsWarning: document.getElementById('totalPointsWarning'),
                cloneHP: document.getElementById('cloneHP'),
                cloneAttack: document.getElementById('cloneAttack'),
                clonePrecision: document.getElementById('clonePrecision'),
                cloneDodge: document.getElementById('cloneDodge'),
                result: document.getElementById('result')
            };

            // 恢复输入值
            for (const key in elements) {
                if (elements[key]) {
                    elements[key].value = localStorage.getItem(key) || elements[key].value;
                }
            }
            
            // 获取实际总点数
            const currentTotalPoints = getCurrentTotalPoints();
            elements.totalPointsValue.textContent = currentTotalPoints;
            elements.totalPointsWarning.innerHTML = `加点总和发生变化！当前总点数：<span id="totalPointsValue">${currentTotalPoints}</span>`;

            updateEnemyStats();
            updateCloneStats();
        };

        // 获取当前总点数
        function getCurrentTotalPoints() {
            const A = parseInt(document.getElementById('addAttack').value) || 0;
            const B = parseInt(document.getElementById('addArmor').value) || 0;
            const C = parseInt(document.getElementById('addPrecision').value) || 0;
            const D = parseInt(document.getElementById('addDodge').value) || 0;
            return A + B + C + D;
        }

        // 节流函数
        function throttle(func, limit) {
            let lastFunc;
            let lastRan;
            return function() {
                const context = this;
                const args = arguments;
                if (!lastRan) {
                    func.apply(context, args);
                    lastRan = Date.now();
                } else {
                    clearTimeout(lastFunc);
                    lastFunc = setTimeout(function() {
                        if ((Date.now() - lastRan) >= limit) {
                            func.apply(context, args);
                            lastRan = Date.now();
                        }
                    }, limit - (Date.now() - lastRan));
                }
            };
        }

        // 更新克隆人统计数据
        const updateCloneStats = throttle(function() {
            const A = parseInt(document.getElementById('addAttack').value) || 0;
            const B = parseInt(document.getElementById('addArmor').value) || 0;
            const C = parseInt(document.getElementById('addPrecision').value) || 0;
            const D = parseInt(document.getElementById('addDodge').value) || 0;
            const cloneCount = parseInt(document.getElementById('cloneCount').value) || 1;
            const totalPoints = A + B + C + D;

            document.getElementById('totalPoints').textContent = totalPoints;
            document.getElementById('totalPointsValue').textContent = totalPoints;

            const warning = document.getElementById('totalPointsWarning');
            warning.style.display = 'none'; // 移除警告，总点数自适应

            // 计算克隆人参数
            const baseCloneHP = parseFloat(document.getElementById('baseCloneHP').value);
            const baseCloneAttack = parseFloat(document.getElementById('baseCloneAttack').value);
            const cloneStats = {
                cloneHP: ((baseCloneHP + 7 * B) * 1.1).toFixed(1),
                cloneAttack: (baseCloneAttack + 7 * A) * cloneCount,
                clonePrecision: C,
                cloneDodge: D
            };

            // 更新DOM
            document.getElementById('cloneHP').textContent = cloneStats.cloneHP;
            document.getElementById('cloneAttack').textContent = cloneStats.cloneAttack;
            document.getElementById('clonePrecision').textContent = cloneStats.clonePrecision;
            document.getElementById('cloneDodge').textContent = cloneStats.cloneDodge;

            // 缓存克隆人统计数据
            cloneStatsCache = cloneStats;
        }, 100); // 每100毫秒更新一次

        // 在输入时保存数据
        document.querySelectorAll('input').forEach(input => {
            input.addEventListener('input', saveToLocalStorage);
        });

        function saveToLocalStorage() {
            const elements = {
                enemyLevel: document.getElementById('enemyLevel'),
                damageMultiplier: document.getElementById('damageMultiplier'),
                cloneCount: document.getElementById('cloneCount'),
                baseCloneHP: document.getElementById('baseCloneHP'),
                baseCloneAttack: document.getElementById('baseCloneAttack'),
                critChance: document.getElementById('critChance'),
                critDamage: document.getElementById('critDamage'),
                reAttackChance: document.getElementById('reAttackChance'),
                addAttack: document.getElementById('addAttack'),
                addPrecision: document.getElementById('addPrecision'),
                addDodge: document.getElementById('addDodge'),
                addArmor: document.getElementById('addArmor'),
                simCount: document.getElementById('simCount'),
                modifyRange: document.getElementById('modifyRange'),
                stepSize: document.getElementById('stepSize')
            };

            for (const key in elements) {
                if (elements[key]) {
                    localStorage.setItem(key, elements[key].value);
                }
            }
        }

        function updateEnemyStats() {
            const level = parseInt(document.getElementById('enemyLevel').value) || 1;
            const damageMultiplier = parseFloat(document.getElementById('damageMultiplier').value) || 1.3;
            const enemyAttack = (7 * level).toFixed(0);
            const enemyPrecision = (level * 2).toFixed(0);
            const enemyDodge = (level * 2).toFixed(0);
            const enemyHP = (level * 800 / damageMultiplier).toFixed(0); // 修改为模拟伤害的倍率

            document.getElementById('enemyHP').textContent = enemyHP;
            document.getElementById('enemyAttack').textContent = enemyAttack;
            document.getElementById('enemyPrecision').textContent = enemyPrecision;
            document.getElementById('enemyDodge').textContent = enemyDodge;
        }

        function getParamsForLevel(level) {
            const enemyHP = (level * 800 / (parseFloat(document.getElementById('damageMultiplier').value) || 1.3)).toFixed(0);
            const enemyAttack = (7 * level).toFixed(0);
            const enemyPrecision = (level * 2).toFixed(0);
            const enemyDodge = (level * 2).toFixed(0);

            return {
                enemyHP: parseFloat(enemyHP),
                enemyAttack: parseFloat(enemyAttack),
                enemyPrecision: parseFloat(enemyPrecision),
                enemyDodge: parseFloat(enemyDodge),
                cloneCount: parseInt(document.getElementById('cloneCount').value),
                cloneHP: parseFloat(document.getElementById('cloneHP').textContent),
                cloneAttack: parseFloat(document.getElementById('cloneAttack').textContent),
                clonePrecision: parseFloat(document.getElementById('clonePrecision').textContent),
                cloneDodge: parseFloat(document.getElementById('cloneDodge').textContent),
                critChance: parseFloat(document.getElementById('critChance').value) / 100,
                critDamage: parseFloat(document.getElementById('critDamage').value) / 100,
                reAttackChance: parseFloat(document.getElementById('reAttackChance').value) / 100
            };
        }

        const workerScript = `
            self.onmessage = function(e) {
                const params = e.data.params;
                const simCount = e.data.simCount;
                const log = e.data.log || false;
                let winCount = 0;
                let logText = '';

                function simulateSingleBattle(params, log) {
                    let {
                        enemyHP, enemyAttack, enemyPrecision, enemyDodge,
                        cloneCount, cloneHP, cloneAttack, clonePrecision, cloneDodge,
                        critChance, critDamage, reAttackChance
                    } = params;

                    let currentEnemyHP = enemyHP;
                    let clones = Array(cloneCount).fill(cloneHP);
                    let round = 1;
                    let logText = '';

                    while (currentEnemyHP > 0 && clones.some(hp => hp > 0)) {
                        // 敌人攻击阶段
                        clones.forEach((hp, index) => {
                            if (hp > 0) {
                                const hitChance = enemyPrecision / (enemyPrecision + cloneDodge);
                                if (Math.random() < hitChance) {
                                    clones[index] -= enemyAttack;
                                    if (log) logText += \`克隆人 \${index + 1} 受到 \${enemyAttack} 伤害，剩余生命值: \${clones[index] > 0 ? clones[index] : 0}\\n\`;
                                } else if (log) logText += \`克隆人 \${index + 1} 闪避了攻击\\n\`;
                            }
                        });

                        // 克隆人攻击阶段
                        clones.forEach((hp, index) => {
                            if (hp > 0) {
                                let totalDamage = 0;
                                const attackTimes = Math.random() < reAttackChance ? 2 : 1; // 每回合只判定一次双重射击

                                for (let i = 0; i < attackTimes; i++) {
                                    const hitChance = clonePrecision / (clonePrecision + enemyDodge);
                                    if (Math.random() < hitChance) {
                                        let damage = cloneAttack;
                                        if (Math.random() < critChance) {
                                            damage *= critDamage;
                                            if (log) logText += \`克隆人 \${index + 1} 第\${i + 1}次攻击暴击! \`;
                                        } else if (log) logText += \`克隆人 \${index + 1} 第\${i + 1}次攻击命中 \`;
                                        totalDamage += damage;
                                    } else if (log) logText += \`克隆人 \${index + 1} 第\${i + 1}次攻击未命中 \`;
                                }

                                if (log && attackTimes === 2) logText += \`克隆人 \${index + 1} 触发双重射击!\\n\`;
                                currentEnemyHP -= totalDamage;
                                if (log) logText += \`克隆人 \${index + 1} 总共造成 \${totalDamage} 伤害，敌人剩余生命值: \${currentEnemyHP > 0 ? currentEnemyHP : 0}\\n\`;
                            }
                        });

                        round++;
                        if (round > 100) break; // 防止无限战斗
                    }

                    if (log && currentEnemyHP <= 0) logText += '战斗胜利！\\n';
                    else if (log) logText += '战斗失败！\\n';

                    return { win: currentEnemyHP <= 0, logText };
                }

                for (let i = 0; i < simCount; i++) {
                    const result = simulateSingleBattle(params, log && i === 0);
                    if (result.win) winCount++;
                    if (log && i === 0) logText = result.logText;
                }

                self.postMessage({ winCount, logText });
            };
        `;
        const blob = new Blob([workerScript], { type: 'application/javascript' });
        const worker = new Worker(URL.createObjectURL(blob));

        function simulateBattle() {
            const params = getParamsForLevel(parseInt(document.getElementById('enemyLevel').value));
            // 移除总点数限制检查
            worker.onmessage = function(e) {
                const logText = e.data.logText;
                document.getElementById('result').textContent = logText;
            };
            worker.postMessage({ params, simCount: 1, log: true });
        }

        async function batchSimulate() {
            // 移除总点数限制检查
            const simCount = parseInt(document.getElementById('simCount').value);
            if (isNaN(simCount) || simCount < 1) {
                document.getElementById('result').textContent = '请输入有效的模拟次数！';
                return;
            }

            const baseLevel = parseInt(document.getElementById('enemyLevel').value);
            const levels = [];
            for (let i = -4; i <= 4; i++) {
                const level = baseLevel + i;
                if (level >= 1) levels.push(level);
            }

            const results = [];
            for (const level of levels) {
                const params = getParamsForLevel(level);
                const winRate = await new Promise((resolve) => {
                    worker.onmessage = function(e) {
                        resolve((e.data.winCount / simCount) * 100);
                    };
                    worker.postMessage({ params, simCount });
                });
                const coinReward = 300 + 30 * level;
                const expectedCoins = (winRate / 100) * coinReward;
                results.push({ level, winRate, expectedCoins });
            }

            const bestCoinResult = results.reduce((max, curr) => 
                curr.expectedCoins > max.expectedCoins ? curr : max, results[0]);

            let resultHTML = '<h2>批量模拟结果（±4等级）</h2><table border="1"><tr><th>敌人等级</th><th>胜率</th><th>预期游戏币收益</th></tr>';
            results.forEach(r => {
                resultHTML += `<tr><td>${r.level}</td><td>${r.winRate.toFixed(2)}%</td><td>${r.expectedCoins.toFixed(2)}</td></tr>`;
            });
            resultHTML += '</table>';
            resultHTML += `<p>最佳游戏币收益：等级 ${bestCoinResult.level}，预期收益 ${bestCoinResult.expectedCoins.toFixed(2)} 币，胜率 ${bestCoinResult.winRate.toFixed(2)}%</p>`;
            document.getElementById('result').innerHTML = resultHTML;
        }

        async function findBestBuild() {
            const totalPoints = getCurrentTotalPoints(); // 使用当前的总点数
            const simCount = 3600;
            let range = parseInt(document.getElementById('modifyRange').value) || 8; // 使用修改范围输入框的值
            let stepSize = parseInt(document.getElementById('stepSize').value) || 1; // 使用步长输入框的值

            const originalRange = range; // 保存原始范围
            const originalStepSize = stepSize; // 保存原始步长

            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('progressBar').value = 0;
            document.getElementById('progressText').textContent = '0%';
            document.getElementById('result').textContent = '正在寻找最佳加点组合...';

            let currentBuild = {
                A: parseInt(document.getElementById('addAttack').value) || 0,
                B: parseInt(document.getElementById('addArmor').value) || 0,
                C: parseInt(document.getElementById('addPrecision').value) || 0,
                D: parseInt(document.getElementById('addDodge').value) || 0
            };

            const initialSum = currentBuild.A + currentBuild.B + currentBuild.C + currentBuild.D;
            if (initialSum !== totalPoints) {
                document.getElementById('result').textContent = `注意：当前加点总和已变更为 ${totalPoints}`;
                // 继续执行，不再限制必须等于初始值
            }

            let topBuilds = [];

            async function searchBuild() {
                const variations = [];
                for (let dA = -range; dA <= range; dA += stepSize) { // 使用步长
                    for (let dB = -range; dB <= range; dB += stepSize) { // 使用步长
                        for (let dC = -range; dC <= range; dC += stepSize) { // 使用步长
                            const dD = -(dA + dB + dC);
                            if (dD >= -range && dD <= range) {
                                variations.push({ dA, dB, dC, dD });
                            }
                        }
                    }
                }

                document.getElementById('progressBar').max = variations.length;

                for (let i = 0; i < variations.length; i++) {
                    const { dA, dB, dC, dD } = variations[i];
                    const newBuild = {
                        A: Math.max(0, Math.min(totalPoints, currentBuild.A + dA)),
                        B: Math.max(0, Math.min(totalPoints, currentBuild.B + dB)),
                        C: Math.max(0, Math.min(totalPoints, currentBuild.C + dC)),
                        D: Math.max(0, Math.min(totalPoints, currentBuild.D + dD))
                    };

                    const sum = newBuild.A + newBuild.B + newBuild.C + newBuild.D;
                    if (sum !== totalPoints) continue;

                    const winRate = await evaluateBuild(newBuild, simCount);
                    const refinedBuild = await refineBuild(newBuild, simCount);
                    topBuilds.push(refinedBuild);
                    topBuilds.sort((a, b) => b.winRate - a.winRate);
                    topBuilds = topBuilds.slice(0, 6); // 修改为显示6个最佳方案

                    const progress = ((i + 1) / variations.length * 100).toFixed(2);
                    requestAnimationFrame(() => {
                        document.getElementById('progressBar').value = i + 1;
                        document.getElementById('progressText').textContent = `${progress}%`;
                    });

                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            await searchBuild(); // 第一次搜索

            // 如果步长不等于1，进行调整并继续搜索
            while (stepSize > 1) {
                stepSize -= 1; // 步长减1
                range = Math.ceil(range / 2); // 范围变为原来的一半并向上取整
                document.getElementById('stepSize').value = stepSize; // 更新输入框的值
                document.getElementById('modifyRange').value = range; // 更新输入框的值
                await searchBuild(); // 继续搜索
            }

            let resultHTML = '<h2>最佳6个加点方案</h2><table border="1"><tr><th>排名</th><th>能量</th><th>精准</th><th>闪避</th><th>装甲</th><th>胜率</th></tr>';
            topBuilds.forEach((build, index) => {
                resultHTML += `<tr><td>${index + 1}</td><td>${build.A}</td><td>${build.C}</td><td>${build.D}</td><td>${build.B}</td><td>${build.winRate.toFixed(2)}%</td></tr>`;
            });
            resultHTML += '</table>';
            document.getElementById('result').innerHTML = resultHTML;

            const bestBuild = topBuilds[0];
            document.getElementById('addAttack').value = bestBuild.A;
            document.getElementById('addPrecision').value = bestBuild.C;
            document.getElementById('addDodge').value = bestBuild.D;
            document.getElementById('addArmor').value = bestBuild.B;
            updateCloneStats();

            // 恢复原始的修改范围和步长
            document.getElementById('modifyRange').value = originalRange;
            document.getElementById('stepSize').value = originalStepSize;
        }

        function evaluateBuild(build, simCount) {
            const total = build.A + build.B + build.C + build.D;
            const currentTotal = getCurrentTotalPoints();
            
            if (total !== currentTotal) return 0; // 使用当前的总点数，不再是固定常量

            const params = {
                enemyHP: parseFloat(document.getElementById('enemyHP').textContent),
                enemyAttack: parseFloat(document.getElementById('enemyAttack').textContent),
                enemyPrecision: parseFloat(document.getElementById('enemyPrecision').textContent),
                enemyDodge: parseFloat(document.getElementById('enemyDodge').textContent),
                cloneCount: parseInt(document.getElementById('cloneCount').value),
                cloneHP: parseFloat(document.getElementById('baseCloneHP').value) + 7 * build.B,
                cloneAttack: parseFloat(document.getElementById('baseCloneAttack').value) + 7 * build.A * parseInt(document.getElementById('cloneCount').value), // 修正错误
                clonePrecision: build.C,
                cloneDodge: build.D,
                critChance: parseFloat(document.getElementById('critChance').value) / 100,
                critDamage: parseFloat(document.getElementById('critDamage').value) / 100,
                reAttackChance: parseFloat(document.getElementById('reAttackChance').value) / 100
            };

            return new Promise((resolve) => {
                worker.onmessage = function(e) {
                    resolve((e.data.winCount / simCount) * 100);
                };
                worker.postMessage({ params, simCount });
            });
        }

        async function refineBuild(build, simCount) {
            const total = build.A + build.B + build.C + build.D;
            const currentTotal = getCurrentTotalPoints();
            
            if (total !== currentTotal) {
                document.getElementById('result').textContent = `当前加点总和为 ${currentTotal}，与模拟起始值不同`;
                return { A: 0, B: 0, C: 0, D: 0, cloneHP: 0, cloneAttack: 0, clonePrecision: 0, cloneDodge: 0, winRate: 0 };
            }

            await new Promise(resolve => {
                requestAnimationFrame(() => {
                    document.getElementById('addAttack').value = build.A;
                    document.getElementById('addPrecision').value = build.C;
                    document.getElementById('addDodge').value = build.D;
                    document.getElementById('addArmor').value = build.B;
                    updateCloneStats();
                    resolve();
                });
            });

            const params = getParamsForLevel(parseInt(document.getElementById('enemyLevel').value));
            return new Promise((resolve) => {
                worker.onmessage = function(e) {
                    const winRate = (e.data.winCount / simCount) * 100;
                    resolve({
                        A: build.A, B: build.B, C: build.C, D: build.D,
                        cloneHP: parseFloat(document.getElementById('cloneHP').textContent),
                        cloneAttack: parseFloat(document.getElementById('cloneAttack').textContent),
                        clonePrecision: parseFloat(document.getElementById('clonePrecision').textContent),
                        cloneDodge: parseFloat(document.getElementById('cloneDodge').textContent),
                        winRate
                    });
                };
                worker.postMessage({ params, simCount });
            });
        }

        function resetToAverage() {
            const totalPoints = getCurrentTotalPoints();
            const basePoints = Math.floor(totalPoints / 4); // 每个属性的基本分配
            const remainder = totalPoints % 4; // 余数

            // 重置加点
            document.getElementById('addAttack').value = basePoints; // 能量
            document.getElementById('addPrecision').value = basePoints; // 精准
            document.getElementById('addDodge').value = basePoints; // 闪避
            document.getElementById('addArmor').value = basePoints; // 装甲

            // 处理余数，优先分配给精准、闪避、装甲、能量
            if (remainder > 0) {
                document.getElementById('addPrecision').value = parseInt(document.getElementById('addPrecision').value) + 1;
            }
            if (remainder > 1) {
                document.getElementById('addDodge').value = parseInt(document.getElementById('addDodge').value) + 1;
            }
            if (remainder > 2) {
                document.getElementById('addArmor').value = parseInt(document.getElementById('addArmor').value) + 1;
            }
            // 更新克隆人统计数据
            updateCloneStats();
        }
    </script>
</body>
</html>