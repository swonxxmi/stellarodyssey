<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>战斗与加点模拟器</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .form-group { margin-bottom: 10px; }
        label { display: inline-block; width: 150px; }
        input[type="number"] { width: 100px; }
        #result { margin-top: 20px; padding: 10px; border: 1px solid #ccc; white-space: pre-wrap; }
        h2 { margin-top: 20px; }
        #progressContainer { margin-top: 10px; display: none; }
        #totalPointsWarning { color: red; display: none; }
        table { border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 8px; text-align: center; border: 1px solid #ccc; }
        th { background-color: #f2f2f2; }
        #analysisPanel { display: block; }
    </style>
</head>
<body>
    <div style="display: flex;">
        <div style="flex: 1; margin-right: 20px;">
            <h2>克隆人装备与属性</h2>
            <div class="form-group">
                <label>数量:</label>
                <input type="number" id="cloneCount" value="1" oninput="updateCloneStats()">
            </div>
            <div class="form-group">
                <label>武器伤害:</label>
                <input type="number" id="baseCloneAttack" value="70" oninput="updateCloneStats()">
            </div>
            <div class="form-group">
                <label>护盾防御:</label>
                <input type="number" id="baseCloneHP" value="800" oninput="updateCloneStats()">
            </div>
            <div class="form-group">
                <label>暴击几率 (%):</label>
                <input type="number" id="critChance" value="0" step="0.1">
            </div>
            <div class="form-group">
                <label>暴击伤害 (%):</label>
                <input type="number" id="critDamage" value="0" step="0.1">
            </div>
            <div class="form-group">
                <label>双重射击 (%):</label>
                <input type="number" id="reAttackChance" value="0" step="0.1">
            </div>

            <h2>统计数据分配</h2>
            <div class="form-group">
                <label>能量加点 (A):</label>
                <input type="number" id="addAttack" value="10" min="0"  oninput="updateCloneStats()">
            </div>
            <div class="form-group">
                <label>精准加点 (C):</label>
                <input type="number" id="addPrecision" value="10" min="0"  oninput="updateCloneStats()">
            </div>
            <div class="form-group">
                <label>闪避加点 (D):</label>
                <input type="number" id="addDodge" value="10" min="0"  oninput="updateCloneStats()">
            </div>
            <div class="form-group">
                <label>装甲加点 (B):</label>
                <input type="number" id="addArmor" value="10" min="0"  oninput="updateCloneStats()">
            </div>
            <div class="form-group">
                <label>加点总和:</label>
                <span id="totalPoints">0</span>
                <span id="totalPointsWarning">加点总和发生变化！当前总点数：<span id="totalPointsValue">0</span></span>
            </div>
            <button type="button" onclick="resetToAverage()">平均分配</button>

            <h2>克隆人综合统计数据</h2>
            <div class="form-group">
                <label>玩家生命值:</label>
                <span id="cloneHP">800</span>
            </div>
            <div class="form-group">
                <label>玩家伤害:</label>
                <span id="cloneAttack">7</span>
            </div>
            <div class="form-group">
                <label>精准:</label>
                <span id="clonePrecision">2</span>
            </div>
            <div class="form-group">
                <label>闪避:</label>
                <span id="cloneDodge">2</span>
            </div>
            <div class="form-group">
                <label>会员状态:</label>
                <input type="checkbox" id="vipStatus" onchange="updateCloneStats()">
                <span>(生命值提升1.1倍)</span>
            </div>
            <div class="form-group">
                <label>静默搜索:</label>
                <input type="checkbox" id="silentSearch" checked>
                <span>(不实时更新属性)</span>
            </div>
        </div>

        <div style="flex: 1;">
            <h2>敌人参数</h2>
            <div class="form-group">
                <label>敌人等级:</label>
                <input type="number" id="enemyLevel" value="1" min="1" oninput="updateEnemyStats()">
            </div>
            <div class="form-group">
                <label>模组伤害加成:</label>
                <input type="number" id="damageMultiplier" value="1" step="0.15" oninput="updateEnemyStats()">
            </div>
            <div class="form-group">
                <label>生命值:</label>
                <span id="enemyHP">0</span>
            </div>
            <div class="form-group">
                <label>攻击力:</label>
                <span id="enemyAttack">0</span>
            </div>
            <div class="form-group">
                <label>精准:</label>
                <span id="enemyPrecision">0</span>
            </div>
            <div class="form-group">
                <label>闪避:</label>
                <span id="enemyDodge">0</span>
            </div>

            <h2>模拟设置</h2>
            <div class="form-group">
                <label>批量模拟次数:</label>
                <input type="number" id="simCount" value="36000" min="1">
            </div>

            
            <div class="form-group">
                <label>修改范围:</label>
                <input type="number" id="modifyRange" value="24" min="1">
            </div>
            <div class="form-group">
                <label>步长:</label>
                <input type="number" id="stepSize" value="3" min="1">
            </div>
            <div class="form-group">
                <label>新增加点数:</label>
                <input type="number" id="additionalPoints" value="5" min="1">
            </div>
            <div class="form-group">
                <label>收起属性升级:</label>
                <input type="checkbox" id="hideAnalysis" onchange="toggleAnalysisPanel()" checked>
            </div>
            <div class="form-group">
                <label>自动赋予加点:</label>
                <input type="checkbox" id="dontApplyBuild" checked>
            </div>

            <h2>收益分析</h2>
            <div id="analysisPanel">
                <div class="form-group">
                    <label>新增克隆人成本:</label>
                    <input type="number" id="clonePrice" value="100000000">
                </div>
                <button type="button" onclick="compareUpgrades()">比较升级收益</button>
                
                <div class="form-group" style="margin-top: 10px;">
                    <label>查看属性升级曲线:</label>
                    <select id="attributeSelect">
                        <option value="critChance">暴击几率</option>
                        <option value="critDamage">暴击伤害</option>
                        <option value="reAttackChance">双重射击</option>
                    </select>
                    <button type="button" onclick="showUpgradeCurve()">显示升级曲线</button>
                    <label><input type="checkbox" id="debugMode"> 开启调试模式</label>
                </div>
            </div>

            <button type="button" onclick="simulateBattle()">模拟单次战斗</button>
            <button type="button" onclick="batchSimulate()">批量模拟当前加点</button>
            <button type="button" onclick="findBestBuild()">寻找最优加点</button>
            <button type="button" onclick="findBestAdditionalPoints()">寻找最优新增加点</button>

            <div id="progressContainer"> 
                <progress id="progressBar" value="0" max="100"></progress>
                <span id="progressText">0%</span>
            </div>
            <div id="result"></div>
        </div>
    </div>

    <script>
        let cloneStatsCache = {}; // 缓存克隆人统计数据

        // 页面加载时恢复输入值
        window.onload = function() {
            const elements = {
                enemyLevel: document.getElementById('enemyLevel'),
                damageMultiplier: document.getElementById('damageMultiplier'),
                cloneCount: document.getElementById('cloneCount'),
                baseCloneHP: document.getElementById('baseCloneHP'),
                baseCloneAttack: document.getElementById('baseCloneAttack'),
                critChance: document.getElementById('critChance'),
                critDamage: document.getElementById('critDamage'),
                reAttackChance: document.getElementById('reAttackChance'),
                addAttack: document.getElementById('addAttack'),
                addPrecision: document.getElementById('addPrecision'),
                addDodge: document.getElementById('addDodge'),
                addArmor: document.getElementById('addArmor'),
                simCount: document.getElementById('simCount'),
                modifyRange: document.getElementById('modifyRange'),
                stepSize: document.getElementById('stepSize'),
                additionalPoints: document.getElementById('additionalPoints'),
                totalPointsValue: document.getElementById('totalPointsValue'),
                totalPointsWarning: document.getElementById('totalPointsWarning'),
                cloneHP: document.getElementById('cloneHP'),
                cloneAttack: document.getElementById('cloneAttack'),
                clonePrecision: document.getElementById('clonePrecision'),
                cloneDodge: document.getElementById('cloneDodge'),
                result: document.getElementById('result'),
                hideAnalysis: document.getElementById('hideAnalysis'),
                dontApplyBuild: document.getElementById('dontApplyBuild'),
                vipStatus: document.getElementById('vipStatus'),
                silentSearch: document.getElementById('silentSearch')
            };

            // 恢复输入值
            for (const key in elements) {
                if (elements[key] && key !== 'hideAnalysis' && key !== 'dontApplyBuild' && key !== 'vipStatus' && key !== 'silentSearch') {
                    elements[key].value = localStorage.getItem(key) || elements[key].value;
                }
            }
            
            // 设置选项的默认状态
            const hideAnalysis = localStorage.getItem('hideAnalysis');
            elements.hideAnalysis.checked = hideAnalysis !== null ? hideAnalysis === 'true' : true;
            
            const dontApplyBuild = localStorage.getItem('dontApplyBuild');
            elements.dontApplyBuild.checked = dontApplyBuild !== null ? dontApplyBuild === 'true' : true;

            const vipStatus = localStorage.getItem('vipStatus');
            elements.vipStatus.checked = vipStatus !== null ? vipStatus === 'true' : false;
            
            const silentSearch = localStorage.getItem('silentSearch');
            elements.silentSearch.checked = silentSearch !== null ? silentSearch === 'true' : true;
            
            // 获取实际总点数
            const currentTotalPoints = getCurrentTotalPoints();
            elements.totalPointsValue.textContent = currentTotalPoints;
            elements.totalPointsWarning.innerHTML = `加点总和发生变化！当前总点数：<span id="totalPointsValue">${currentTotalPoints}</span>`;

            updateEnemyStats();
            updateCloneStats();
            
            // 应用收益分析面板显示状态
            toggleAnalysisPanel();
        };

        // 获取当前总点数
        function getCurrentTotalPoints() {
            const A = parseInt(document.getElementById('addAttack').value) || 0;
            const B = parseInt(document.getElementById('addArmor').value) || 0;
            const C = parseInt(document.getElementById('addPrecision').value) || 0;
            const D = parseInt(document.getElementById('addDodge').value) || 0;
            return A + B + C + D;
        }

        // 节流函数
        function throttle(func, limit) {
            let lastFunc;
            let lastRan;
            return function() {
                const context = this;
                const args = arguments;
                if (!lastRan) {
                    func.apply(context, args);
                    lastRan = Date.now();
                } else {
                    clearTimeout(lastFunc);
                    lastFunc = setTimeout(function() {
                        if ((Date.now() - lastRan) >= limit) {
                            func.apply(context, args);
                            lastRan = Date.now();
                        }
                    }, limit - (Date.now() - lastRan));
                }
            };
        }

        // 更新克隆人统计数据
        const updateCloneStats = throttle(function() {
            const A = parseInt(document.getElementById('addAttack').value) || 0;
            const B = parseInt(document.getElementById('addArmor').value) || 0;
            const C = parseInt(document.getElementById('addPrecision').value) || 0;
            const D = parseInt(document.getElementById('addDodge').value) || 0;
            const cloneCount = parseInt(document.getElementById('cloneCount').value) || 1;
            const totalPoints = A + B + C + D;

            document.getElementById('totalPoints').textContent = totalPoints;
            document.getElementById('totalPointsValue').textContent = totalPoints;

            const warning = document.getElementById('totalPointsWarning');
            warning.style.display = 'none'; // 移除警告，总点数自适应

            // 计算克隆人参数
            const baseCloneHP = parseFloat(document.getElementById('baseCloneHP').value);
            const baseCloneAttack = parseFloat(document.getElementById('baseCloneAttack').value);
            const isVip = document.getElementById('vipStatus').checked;
            const cloneStats = {
                cloneHP: ((baseCloneHP + 7 * B) * (isVip ? 1.1 : 1)).toFixed(1),
                cloneAttack: (baseCloneAttack + 7 * A) * cloneCount,
                clonePrecision: C,
                cloneDodge: D
            };

            // 更新DOM
            document.getElementById('cloneHP').textContent = cloneStats.cloneHP;
            document.getElementById('cloneAttack').textContent = cloneStats.cloneAttack;
            document.getElementById('clonePrecision').textContent = cloneStats.clonePrecision;
            document.getElementById('cloneDodge').textContent = cloneStats.cloneDodge;

            // 缓存克隆人统计数据
            cloneStatsCache = cloneStats;
        }, 100); // 每100毫秒更新一次

        // 在输入时保存数据
        document.querySelectorAll('input').forEach(input => {
            input.addEventListener('input', saveToLocalStorage);
        });

        function saveToLocalStorage() {
            const elements = {
                enemyLevel: document.getElementById('enemyLevel'),
                damageMultiplier: document.getElementById('damageMultiplier'),
                cloneCount: document.getElementById('cloneCount'),
                baseCloneHP: document.getElementById('baseCloneHP'),
                baseCloneAttack: document.getElementById('baseCloneAttack'),
                critChance: document.getElementById('critChance'),
                critDamage: document.getElementById('critDamage'),
                reAttackChance: document.getElementById('reAttackChance'),
                addAttack: document.getElementById('addAttack'),
                addPrecision: document.getElementById('addPrecision'),
                addDodge: document.getElementById('addDodge'),
                addArmor: document.getElementById('addArmor'),
                simCount: document.getElementById('simCount'),
                modifyRange: document.getElementById('modifyRange'),
                stepSize: document.getElementById('stepSize'),
                additionalPoints: document.getElementById('additionalPoints'),
                hideAnalysis: document.getElementById('hideAnalysis'),
                dontApplyBuild: document.getElementById('dontApplyBuild'),
                vipStatus: document.getElementById('vipStatus'),
                silentSearch: document.getElementById('silentSearch')
            };

            for (const key in elements) {
                if (elements[key]) {
                    if (key === 'hideAnalysis' || key === 'dontApplyBuild' || key === 'vipStatus' || key === 'silentSearch') {
                        localStorage.setItem(key, elements[key].checked);
                    } else {
                        localStorage.setItem(key, elements[key].value);
                    }
                }
            }
        }

        function updateEnemyStats() {
            const level = parseInt(document.getElementById('enemyLevel').value) || 1;
            const damageMultiplier = parseFloat(document.getElementById('damageMultiplier').value) || 1.3;
            const enemyAttack = (7 * level).toFixed(0);
            const enemyPrecision = (level * 2).toFixed(0);
            const enemyDodge = (level * 2).toFixed(0);
            const enemyHP = (level * 800 / damageMultiplier).toFixed(0); // 修改为模拟伤害的倍率

            document.getElementById('enemyHP').textContent = enemyHP;
            document.getElementById('enemyAttack').textContent = enemyAttack;
            document.getElementById('enemyPrecision').textContent = enemyPrecision;
            document.getElementById('enemyDodge').textContent = enemyDodge;
        }

        function getParamsForLevel(level) {
            const enemyHP = (level * 800 / (parseFloat(document.getElementById('damageMultiplier').value) || 1.3)).toFixed(0);
            const enemyAttack = (7 * level).toFixed(0);
            const enemyPrecision = (level * 2).toFixed(0);
            const enemyDodge = (level * 2).toFixed(0);

            return {
                enemyHP: parseFloat(enemyHP),
                enemyAttack: parseFloat(enemyAttack),
                enemyPrecision: parseFloat(enemyPrecision),
                enemyDodge: parseFloat(enemyDodge),
                cloneCount: parseInt(document.getElementById('cloneCount').value),
                cloneHP: parseFloat(document.getElementById('cloneHP').textContent),
                cloneAttack: parseFloat(document.getElementById('cloneAttack').textContent),
                clonePrecision: parseFloat(document.getElementById('clonePrecision').textContent),
                cloneDodge: parseFloat(document.getElementById('cloneDodge').textContent),
                critChance: parseFloat(document.getElementById('critChance').value) / 100,
                critDamage: (parseFloat(document.getElementById('critDamage').value) + 130) / 100,
                reAttackChance: parseFloat(document.getElementById('reAttackChance').value) / 100
            };
        }

        const workerScript = `
            self.onmessage = function(e) {
                const params = e.data.params;
                const simCount = e.data.simCount;
                const log = e.data.log || false;
                let winCount = 0;
                let logText = '';

                function simulateSingleBattle(params, log) {
                    let {
                        enemyHP, enemyAttack, enemyPrecision, enemyDodge,
                        cloneCount, cloneHP, cloneAttack, clonePrecision, cloneDodge,
                        critChance, critDamage, reAttackChance
                    } = params;
                    
                    // 确保critDamage包含基础值130%
                    critDamage = critDamage || 1.3; // 如果未定义，使用默认值1.3 (130%)

                    let currentEnemyHP = enemyHP;
                    let clones = Array(cloneCount).fill(cloneHP);
                    let round = 1;
                    let logText = '';

                    while (currentEnemyHP > 0 && clones.some(hp => hp > 0)) {
                        // 敌人攻击阶段
                        clones.forEach((hp, index) => {
                            if (hp > 0) {
                                const hitChance = enemyPrecision / (enemyPrecision + cloneDodge);
                                if (Math.random() < hitChance) {
                                    clones[index] -= enemyAttack;
                                    if (log) logText += \`克隆人 \${index + 1} 受到 \${enemyAttack} 伤害，剩余生命值: \${clones[index] > 0 ? clones[index] : 0}\\n\`;
                                } else if (log) logText += \`克隆人 \${index + 1} 闪避了攻击\\n\`;
                            }
                        });

                        // 克隆人攻击阶段
                        clones.forEach((hp, index) => {
                            if (hp > 0) {
                                let totalDamage = 0;
                                const attackTimes = Math.random() < reAttackChance ? 2 : 1; // 每回合只判定一次双重射击

                                for (let i = 0; i < attackTimes; i++) {
                                    const hitChance = clonePrecision / (clonePrecision + enemyDodge);
                                    if (Math.random() < hitChance) {
                                        let damage = cloneAttack;
                                        if (Math.random() < critChance) {
                                            damage *= critDamage;
                                            if (log) logText += \`克隆人 \${index + 1} 第\${i + 1}次攻击暴击! \`;
                                        } else if (log) logText += \`克隆人 \${index + 1} 第\${i + 1}次攻击命中 \`;
                                        totalDamage += damage;
                                    } else if (log) logText += \`克隆人 \${index + 1} 第\${i + 1}次攻击未命中 \`;
                                }

                                if (log && attackTimes === 2) logText += \`克隆人 \${index + 1} 触发双重射击!\\n\`;
                                currentEnemyHP -= totalDamage;
                                if (log) logText += \`克隆人 \${index + 1} 总共造成 \${totalDamage} 伤害，敌人剩余生命值: \${currentEnemyHP > 0 ? currentEnemyHP : 0}\\n\`;
                            }
                        });

                        round++;
                        if (round > 100) break; // 防止无限战斗
                    }

                    if (log && currentEnemyHP <= 0) logText += '战斗胜利！\\n';
                    else if (log) logText += '战斗失败！\\n';

                    return { win: currentEnemyHP <= 0, logText };
                }

                for (let i = 0; i < simCount; i++) {
                    const result = simulateSingleBattle(params, log && i === 0);
                    if (result.win) winCount++;
                    if (log && i === 0) logText = result.logText;
                }

                self.postMessage({ winCount, logText });
            };
        `;
        const blob = new Blob([workerScript], { type: 'application/javascript' });
        const worker = new Worker(URL.createObjectURL(blob));

        function simulateBattle() {
            const params = getParamsForLevel(parseInt(document.getElementById('enemyLevel').value));
            // 移除总点数限制检查
            worker.onmessage = function(e) {
                const logText = e.data.logText;
                document.getElementById('result').textContent = logText;
            };
            worker.postMessage({ params, simCount: 1, log: true });
        }

        async function batchSimulate() {
            // 移除总点数限制检查
            const simCount = parseInt(document.getElementById('simCount').value);
            if (isNaN(simCount) || simCount < 1) {
                document.getElementById('result').textContent = '请输入有效的模拟次数！';
                return;
            }

            const baseLevel = parseInt(document.getElementById('enemyLevel').value);
            
            // 创建两个不同的等级范围数组
            // 1. 游戏币收益：仅±6等级
            const coinLevels = [];
            for (let i = -6; i <= 6; i++) {
                const level = baseLevel + i;
                if (level >= 1) coinLevels.push(level);
            }
            
            // 2. 经验收益：先四舍五入到10的倍数，再±30等级，步长为10
            const roundedBaseLevel = Math.round(baseLevel / 10) * 10; // 四舍五入到10的倍数
            const expLevels = [];
            for (let i = -30; i <= 30; i += 10) {
                const level = roundedBaseLevel + i;
                if (level >= 1) expLevels.push(level);
            }
            // 确保当前等级在列表中（如果不是10的倍数）
            if (!expLevels.includes(baseLevel) && baseLevel >= 1) {
                expLevels.push(baseLevel);
                // 排序确保顺序
                expLevels.sort((a, b) => a - b);
            }
            
            // 合并所有需要模拟的等级（去重）
            const allLevels = [...new Set([...coinLevels, ...expLevels])].sort((a, b) => a - b);

            const results = [];
            for (const level of allLevels) {
                const params = getParamsForLevel(level);
                const winRate = await new Promise((resolve) => {
                    worker.onmessage = function(e) {
                        resolve((e.data.winCount / simCount) * 100);
                    };
                    worker.postMessage({ params, simCount });
                });
                const coinReward = 300 + 30 * level;
                const expectedCoins = (winRate / 100) * coinReward;
                // 添加经验收益计算：30+敌人等级/10(取整)
                const expReward = Math.floor(30 + level/10);
                const expectedExp = (winRate / 100) * expReward;
                results.push({ level, winRate, coinReward, expectedCoins, expReward, expectedExp });
            }

            // 从所有结果中找出最优解
            const bestCoinResult = results.reduce((max, curr) => 
                curr.expectedCoins > max.expectedCoins ? curr : max, results[0]);
                
            const bestExpResult = results.reduce((max, curr) => 
                curr.expectedExp > max.expectedExp ? curr : max, results[0]);

            // 分别显示游戏币和经验的表格
            let resultHTML = '<h2>批量模拟结果</h2>';
            
            // 游戏币收益表格（±6等级）
            resultHTML += '<h3>游戏币收益（±6等级）</h3>';
            resultHTML += '<table border="1"><tr><th>敌人等级</th><th>胜率</th><th>游戏币</th><th>预期游戏币收益</th></tr>';
            results.filter(r => coinLevels.includes(r.level)).forEach(r => {
                resultHTML += `<tr><td>${r.level}</td><td>${r.winRate.toFixed(2)}%</td><td>${r.coinReward}</td><td>${r.expectedCoins.toFixed(2)}</td></tr>`;
            });
            resultHTML += '</table>';
            resultHTML += `<p>最佳游戏币收益：等级 ${bestCoinResult.level}，预期收益 ${bestCoinResult.expectedCoins.toFixed(2)} 币，胜率 ${bestCoinResult.winRate.toFixed(2)}%</p>`;
            
            // 经验收益表格（基于四舍五入后的等级±30，步长10）
            resultHTML += `<h3>经验收益（基于四舍五入到${roundedBaseLevel}级的±30范围，步长10）</h3>`;
            resultHTML += '<table border="1"><tr><th>敌人等级</th><th>胜率</th><th>经验值</th><th>预期经验收益</th></tr>';
            results.filter(r => expLevels.includes(r.level)).forEach(r => {
                resultHTML += `<tr><td>${r.level}</td><td>${r.winRate.toFixed(2)}%</td><td>${r.expReward}</td><td>${r.expectedExp.toFixed(2)}</td></tr>`;
            });
            resultHTML += '</table>';
            resultHTML += `<p>最佳经验收益：等级 ${bestExpResult.level}，预期收益 ${bestExpResult.expectedExp.toFixed(2)} 经验，胜率 ${bestExpResult.winRate.toFixed(2)}%</p>`;
            
            document.getElementById('result').innerHTML = resultHTML;
        }

        async function findBestBuild() {
            const totalPoints = getCurrentTotalPoints(); // 使用当前的总点数
            const simCount = 3600;
            let range = parseInt(document.getElementById('modifyRange').value) || 8; // 使用修改范围输入框的值
            let stepSize = parseInt(document.getElementById('stepSize').value) || 1; // 使用步长输入框的值
            const autoApplyBuild = document.getElementById('dontApplyBuild').checked;

            const originalRange = range; // 保存原始范围
            const originalStepSize = stepSize; // 保存原始步长

            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('progressBar').value = 0;
            document.getElementById('progressText').textContent = '0%';
            document.getElementById('result').textContent = '正在寻找最佳加点组合...';

            let currentBuild = {
                A: parseInt(document.getElementById('addAttack').value) || 0,
                B: parseInt(document.getElementById('addArmor').value) || 0,
                C: parseInt(document.getElementById('addPrecision').value) || 0,
                D: parseInt(document.getElementById('addDodge').value) || 0
            };

            const initialSum = currentBuild.A + currentBuild.B + currentBuild.C + currentBuild.D;
            if (initialSum !== totalPoints) {
                document.getElementById('result').textContent = `注意：当前加点总和已变更为 ${totalPoints}`;
                // 继续执行，不再限制必须等于初始值
            }

            let topBuilds = [];

            async function searchBuild() {
                const variations = [];
                for (let dA = -range; dA <= range; dA += stepSize) { // 使用步长
                    for (let dB = -range; dB <= range; dB += stepSize) { // 使用步长
                        for (let dC = -range; dC <= range; dC += stepSize) { // 使用步长
                            const dD = -(dA + dB + dC);
                            if (dD >= -range && dD <= range) {
                                variations.push({ dA, dB, dC, dD });
                            }
                        }
                    }
                }

                document.getElementById('progressBar').max = variations.length;

                for (let i = 0; i < variations.length; i++) {
                    const { dA, dB, dC, dD } = variations[i];
                    const newBuild = {
                        A: Math.max(0, Math.min(totalPoints, currentBuild.A + dA)),
                        B: Math.max(0, Math.min(totalPoints, currentBuild.B + dB)),
                        C: Math.max(0, Math.min(totalPoints, currentBuild.C + dC)),
                        D: Math.max(0, Math.min(totalPoints, currentBuild.D + dD))
                    };

                    const sum = newBuild.A + newBuild.B + newBuild.C + newBuild.D;
                    if (sum !== totalPoints) continue;

                    const winRate = await evaluateBuild(newBuild, simCount);
                    const refinedBuild = await refineBuild(newBuild, simCount);
                    topBuilds.push(refinedBuild);
                    topBuilds.sort((a, b) => b.winRate - a.winRate);
                    topBuilds = topBuilds.slice(0, 6); // 修改为显示6个最佳方案

                    const progress = ((i + 1) / variations.length * 100).toFixed(2);
                    requestAnimationFrame(() => {
                        document.getElementById('progressBar').value = i + 1;
                        document.getElementById('progressText').textContent = `${progress}%`;
                    });

                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            await searchBuild(); // 第一次搜索

            // 如果步长不等于1，进行调整并继续搜索
            while (stepSize > 1) {
                stepSize -= 1; // 步长减1
                range = Math.ceil(range / 2); // 范围变为原来的一半并向上取整
                document.getElementById('stepSize').value = stepSize; // 更新输入框的值
                document.getElementById('modifyRange').value = range; // 更新输入框的值
                await searchBuild(); // 继续搜索
            }

            let resultHTML = '<h2>最佳6个加点方案</h2><table border="1"><tr><th>排名</th><th>能量</th><th>精准</th><th>闪避</th><th>装甲</th><th>胜率</th></tr>';
            topBuilds.forEach((build, index) => {
                resultHTML += `<tr><td>${index + 1}</td><td>${build.A}</td><td>${build.C}</td><td>${build.D}</td><td>${build.B}</td><td>${build.winRate.toFixed(2)}%</td></tr>`;
            });
            resultHTML += '</table>';
            document.getElementById('result').innerHTML = resultHTML;

            const bestBuild = topBuilds[0];
            if (autoApplyBuild) {
                document.getElementById('addAttack').value = bestBuild.A;
                document.getElementById('addPrecision').value = bestBuild.C;
                document.getElementById('addDodge').value = bestBuild.D;
                document.getElementById('addArmor').value = bestBuild.B;
                updateCloneStats();
            }

            // 恢复原始的修改范围和步长
            document.getElementById('modifyRange').value = originalRange;
            document.getElementById('stepSize').value = originalStepSize;
        }

        function evaluateBuild(build, simCount) {
            const total = build.A + build.B + build.C + build.D;
            const currentTotal = getCurrentTotalPoints();
            
            if (total !== currentTotal) return 0; // 使用当前的总点数，不再是固定常量

            const params = {
                enemyHP: parseFloat(document.getElementById('enemyHP').textContent),
                enemyAttack: parseFloat(document.getElementById('enemyAttack').textContent),
                enemyPrecision: parseFloat(document.getElementById('enemyPrecision').textContent),
                enemyDodge: parseFloat(document.getElementById('enemyDodge').textContent),
                cloneCount: parseInt(document.getElementById('cloneCount').value),
                cloneHP: (parseFloat(document.getElementById('baseCloneHP').value) + 7 * build.B) * (document.getElementById('vipStatus').checked ? 1.1 : 1),
                cloneAttack: (parseFloat(document.getElementById('baseCloneAttack').value) + 7 * build.A) * parseInt(document.getElementById('cloneCount').value),
                clonePrecision: build.C,
                cloneDodge: build.D,
                critChance: parseFloat(document.getElementById('critChance').value) / 100,
                critDamage: (parseFloat(document.getElementById('critDamage').value) + 130) / 100,
                reAttackChance: parseFloat(document.getElementById('reAttackChance').value) / 100
            };

            return new Promise((resolve) => {
                worker.onmessage = function(e) {
                    resolve((e.data.winCount / simCount) * 100);
                };
                worker.postMessage({ params, simCount });
            });
        }

        async function refineBuild(build, simCount) {
            const total = build.A + build.B + build.C + build.D;
            const currentTotal = getCurrentTotalPoints();
            const silentSearch = document.getElementById('silentSearch').checked;
            
            if (total !== currentTotal) {
                document.getElementById('result').textContent = `当前加点总和为 ${currentTotal}，与模拟起始值不同`;
                return { A: 0, B: 0, C: 0, D: 0, cloneHP: 0, cloneAttack: 0, clonePrecision: 0, cloneDodge: 0, winRate: 0 };
            }

            // 计算克隆人属性，不修改DOM
            const baseCloneHP = parseFloat(document.getElementById('baseCloneHP').value);
            const baseCloneAttack = parseFloat(document.getElementById('baseCloneAttack').value);
            const isVip = document.getElementById('vipStatus').checked;
            const cloneCount = parseInt(document.getElementById('cloneCount').value);
            
            const cloneHP = ((baseCloneHP + 7 * build.B) * (isVip ? 1.1 : 1)).toFixed(1);
            const cloneAttack = (baseCloneAttack + 7 * build.A) * cloneCount;
            
            // 如果不是静默搜索，则更新DOM
            if (!silentSearch) {
                await new Promise(resolve => {
                    requestAnimationFrame(() => {
                        document.getElementById('addAttack').value = build.A;
                        document.getElementById('addPrecision').value = build.C;
                        document.getElementById('addDodge').value = build.D;
                        document.getElementById('addArmor').value = build.B;
                        updateCloneStats();
                        resolve();
                    });
                });
                
                const params = getParamsForLevel(parseInt(document.getElementById('enemyLevel').value));
                return new Promise((resolve) => {
                    worker.onmessage = function(e) {
                        const winRate = (e.data.winCount / simCount) * 100;
                        resolve({
                            A: build.A, B: build.B, C: build.C, D: build.D,
                            cloneHP: parseFloat(document.getElementById('cloneHP').textContent),
                            cloneAttack: parseFloat(document.getElementById('cloneAttack').textContent),
                            clonePrecision: parseFloat(document.getElementById('clonePrecision').textContent),
                            cloneDodge: parseFloat(document.getElementById('cloneDodge').textContent),
                            winRate
                        });
                    };
                    worker.postMessage({ params, simCount });
                });
            } else {
                // 静默搜索模式，不更新DOM，直接使用计算的属性
                const params = {
                    enemyHP: parseFloat(document.getElementById('enemyHP').textContent),
                    enemyAttack: parseFloat(document.getElementById('enemyAttack').textContent),
                    enemyPrecision: parseFloat(document.getElementById('enemyPrecision').textContent),
                    enemyDodge: parseFloat(document.getElementById('enemyDodge').textContent),
                    cloneCount: cloneCount,
                    cloneHP: parseFloat(cloneHP),
                    cloneAttack: cloneAttack,
                    clonePrecision: build.C,
                    cloneDodge: build.D,
                    critChance: parseFloat(document.getElementById('critChance').value) / 100,
                    critDamage: (parseFloat(document.getElementById('critDamage').value) + 130) / 100,
                    reAttackChance: parseFloat(document.getElementById('reAttackChance').value) / 100
                };
                
                return new Promise((resolve) => {
                    worker.onmessage = function(e) {
                        const winRate = (e.data.winCount / simCount) * 100;
                        resolve({
                            A: build.A, B: build.B, C: build.C, D: build.D,
                            cloneHP: parseFloat(cloneHP),
                            cloneAttack: cloneAttack,
                            clonePrecision: build.C,
                            cloneDodge: build.D,
                            winRate
                        });
                    };
                    worker.postMessage({ params, simCount });
                });
            }
        }

        function resetToAverage() {
            const totalPoints = getCurrentTotalPoints();
            const basePoints = Math.floor(totalPoints / 4); // 每个属性的基本分配
            const remainder = totalPoints % 4; // 余数

            // 重置加点
            document.getElementById('addAttack').value = basePoints; // 能量
            document.getElementById('addPrecision').value = basePoints; // 精准
            document.getElementById('addDodge').value = basePoints; // 闪避
            document.getElementById('addArmor').value = basePoints; // 装甲

            // 处理余数，优先分配给精准、闪避、装甲、能量
            if (remainder > 0) {
                document.getElementById('addPrecision').value = parseInt(document.getElementById('addPrecision').value) + 1;
            }
            if (remainder > 1) {
                document.getElementById('addDodge').value = parseInt(document.getElementById('addDodge').value) + 1;
            }
            if (remainder > 2) {
                document.getElementById('addArmor').value = parseInt(document.getElementById('addArmor').value) + 1;
            }
            // 更新克隆人统计数据
            updateCloneStats();
        }

        async function findBestAdditionalPoints() {
            const currentPoints = getCurrentTotalPoints();
            const additionalPoints = parseInt(document.getElementById('additionalPoints').value) || 10;
            const newTotalPoints = currentPoints + additionalPoints;
            const simCount = 36000;
            const range = parseInt(document.getElementById('modifyRange').value) || 8;
            const stepSize = parseInt(document.getElementById('stepSize').value) || 1;
            const autoApplyBuild = document.getElementById('dontApplyBuild').checked;

            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('progressBar').value = 0;
            document.getElementById('progressText').textContent = '0%';
            document.getElementById('result').textContent = `正在寻找最佳新增${additionalPoints}点的加点组合...`;

            // 保存当前加点
            const currentBuild = {
                A: parseInt(document.getElementById('addAttack').value) || 0,
                B: parseInt(document.getElementById('addArmor').value) || 0,
                C: parseInt(document.getElementById('addPrecision').value) || 0,
                D: parseInt(document.getElementById('addDodge').value) || 0
            };

            // 生成可能的变化组合
            const variations = [];
            for (let dA = 0; dA <= additionalPoints; dA++) {
                for (let dB = 0; dB <= additionalPoints - dA; dB++) {
                    for (let dC = 0; dC <= additionalPoints - dA - dB; dC++) {
                        const dD = additionalPoints - dA - dB - dC;
                        variations.push({ dA, dB, dC, dD });
                    }
                }
            }

            document.getElementById('progressBar').max = variations.length;
            
            let topBuilds = [];
            for (let i = 0; i < variations.length; i++) {
                const { dA, dB, dC, dD } = variations[i];
                const newBuild = {
                    A: currentBuild.A + dA,
                    B: currentBuild.B + dB,
                    C: currentBuild.C + dC,
                    D: currentBuild.D + dD
                };

                const params = {
                    enemyHP: parseFloat(document.getElementById('enemyHP').textContent),
                    enemyAttack: parseFloat(document.getElementById('enemyAttack').textContent),
                    enemyPrecision: parseFloat(document.getElementById('enemyPrecision').textContent),
                    enemyDodge: parseFloat(document.getElementById('enemyDodge').textContent),
                    cloneCount: parseInt(document.getElementById('cloneCount').value),
                    cloneHP: (parseFloat(document.getElementById('baseCloneHP').value) + 7 * newBuild.B) * (document.getElementById('vipStatus').checked ? 1.1 : 1),
                    cloneAttack: (parseFloat(document.getElementById('baseCloneAttack').value) + 7 * newBuild.A) * parseInt(document.getElementById('cloneCount').value),
                    clonePrecision: newBuild.C,
                    cloneDodge: newBuild.D,
                    critChance: parseFloat(document.getElementById('critChance').value) / 100,
                    critDamage: (parseFloat(document.getElementById('critDamage').value) + 130) / 100,
                    reAttackChance: parseFloat(document.getElementById('reAttackChance').value) / 100
                };

                const winRate = await new Promise((resolve) => {
                    worker.onmessage = function(e) {
                        resolve((e.data.winCount / simCount) * 100);
                    };
                    worker.postMessage({ params, simCount });
                });

                topBuilds.push({
                    ...newBuild,
                    dA, dB, dC, dD,
                    winRate
                });

                topBuilds.sort((a, b) => b.winRate - a.winRate);
                topBuilds = topBuilds.slice(0, 6); // 保留最佳的6个方案

                const progress = ((i + 1) / variations.length * 100).toFixed(2);
                requestAnimationFrame(() => {
                    document.getElementById('progressBar').value = i + 1;
                    document.getElementById('progressText').textContent = `${progress}%`;
                });

                await new Promise(resolve => setTimeout(resolve, 0));
            }

            // 显示结果
            let resultHTML = `<h2>新增${additionalPoints}点的最佳加点方案</h2>`;
            resultHTML += '<table border="1"><tr><th>排名</th><th>能量</th><th>精准</th><th>闪避</th><th>装甲</th><th>新增能量</th><th>新增精准</th><th>新增闪避</th><th>新增装甲</th><th>胜率</th></tr>';
            topBuilds.forEach((build, index) => {
                resultHTML += `<tr><td>${index + 1}</td><td>${build.A}</td><td>${build.C}</td><td>${build.D}</td><td>${build.B}</td><td>${build.dA}</td><td>${build.dC}</td><td>${build.dD}</td><td>${build.dB}</td><td>${build.winRate.toFixed(2)}%</td></tr>`;
            });
            resultHTML += '</table>';
            document.getElementById('result').innerHTML = resultHTML;

            // 应用最佳加点方案
            const bestBuild = topBuilds[0];
            if (autoApplyBuild) {
                document.getElementById('addAttack').value = bestBuild.A;
                document.getElementById('addPrecision').value = bestBuild.C;
                document.getElementById('addDodge').value = bestBuild.D;
                document.getElementById('addArmor').value = bestBuild.B;
                updateCloneStats();
            }
        }

        function calculateExponentialValue(input) {
            const BASE_FACTOR = 5000;
            const GROWTH_RATE = 0.15;
            return BASE_FACTOR * input * Math.exp(GROWTH_RATE * input);
        }

        function sumExponentialRange(start, end) {
            const STEP_SIZE = 0.1;
            let totalSum = 0;
            
            let debugValues = []; // 保持调试功能
            
            for (
                let current = Number((start + STEP_SIZE).toFixed(1)); // 从 start + 0.1 开始
                current <= end;                                       // 直到达到 end
                current = Number((current + STEP_SIZE).toFixed(1))    // 每次增加 0.1
            ) {
                const value = calculateExponentialValue(current);
                totalSum += value;
                if (window.debugMode) { // 保持调试输出
                   debugValues.push({current, value});
                }
            }
            
            if (window.debugMode) {
                console.log("计算区间: ", start, "到", end);
                console.log("计算步骤: ", debugValues);
                console.log("总成本: ", totalSum);
            }
            
            return totalSum;
        }

        // 计算单次升级(+1%)的成本和新值
        function getSingleUpgrade(currentValue, cloneCount) {
            const nextValue = Number((currentValue + 1.0).toFixed(1));
            const cost = sumExponentialRange(currentValue, nextValue) * cloneCount;
            return { maxValue: nextValue, cost: cost };
        }

        // 添加一个函数来显示一个属性的升级曲线
        async function showUpgradeCurve() {
            const attribute = document.getElementById('attributeSelect').value;
            const currentValue = parseFloat(document.getElementById(attribute).value) || 0;
            const cloneCount = parseInt(document.getElementById('cloneCount').value) || 1;
            
            let curveData = [];
            
            // 是否启用调试模式(控制台输出详细计算步骤)
            window.debugMode = document.getElementById('debugMode').checked;
            
            // 对于暴击伤害，不需要减去基础值130%，因为输入框已经是纯增益值
            let actualValue = currentValue;
            
            // 计算不同升级范围的成本
            // 增加0.1%的成本
            const cost01 = sumExponentialRange(actualValue, actualValue + 0.1) * cloneCount;
            // 增加1.0%的成本
            const cost10 = sumExponentialRange(actualValue, actualValue + 1.0) * cloneCount;
            
            // 游戏常见区间的成本计算验证
            let specialCases = [
            
            ];
            
            let verificationHTML = '';
            
            for (let testCase of specialCases) {
                const calculatedCost = sumExponentialRange(testCase.from, testCase.to) * cloneCount;
                verificationHTML += `<tr><td>${testCase.from}%→${testCase.to}%</td><td>${calculatedCost.toFixed(0)}</td><td>${testCase.expectedCost}</td></tr>`;
            }
            
            verificationHTML += '</table>';
            
            // 计算从当前值开始，每+1%的成本，以及累计成本
            let totalCumulativeCost = 0;
            for (let i = 0; i < 10; i++) {
                const startValue = actualValue + i;
                const endValue = startValue + 1.0;
                const stepCost = sumExponentialRange(startValue, endValue) * cloneCount;
                totalCumulativeCost += stepCost;
                
                // 显示的值不需要特殊处理
                let displayFrom = startValue;
                let displayTo = endValue;
                
                curveData.push({
                    from: displayFrom.toFixed(1) + '%',
                    to: displayTo.toFixed(1) + '%',
                    cost: stepCost.toFixed(0),
                    cumulative: totalCumulativeCost.toFixed(0)
                });
            }
            
            // 显示结果
            let resultHTML = `<h3>${attribute === 'critChance' ? '暴击几率' : attribute === 'critDamage' ? '暴击伤害' : '双重射击'}升级成本曲线</h3>`;
            
            resultHTML += `<p>当前值: ${currentValue}%</p>`;
            if (attribute === 'critDamage') {
                resultHTML += `<p>实际战斗暴击伤害: ${(currentValue + 130).toFixed(1)}% (基础值130%+增益${currentValue}%)</p>`;
            }
            resultHTML += `<p>增加0.1%成本: ${cost01.toFixed(0)}</p>`;
            resultHTML += `<p>增加1.0%成本: ${cost10.toFixed(0)}</p>`;
            
            resultHTML += '<table border="1"><tr><th>从</th><th>到</th><th>成本 (货币)</th><th>累计成本</th></tr>';
            
            curveData.forEach(data => {
                resultHTML += `<tr><td>${data.from}</td><td>${data.to}</td><td>${data.cost}</td><td>${data.cumulative}</td></tr>`;
            });
            
            resultHTML += '</table>';
            resultHTML += '<p>注意：成本已乘以当前克隆人数量 ' + cloneCount + '</p>';
            resultHTML += verificationHTML;
            
            document.getElementById('result').innerHTML = resultHTML;
        }

        async function compareUpgrades() {
            const cloneCount = parseInt(document.getElementById('cloneCount').value) || 1;
            const clonePrice = parseFloat(document.getElementById('clonePrice').value) || 100000000;
            const simCount = 360000
            
            // 开启调试模式查看计算过程
            window.debugMode = document.getElementById('debugMode').checked;
            
            document.getElementById('result').innerHTML = '正在计算各项升级收益比较，请稍候...';
            
            // 获取当前值 - 直接从页面输入框获取而不是current开头的输入框
            const currentCritChance = parseFloat(document.getElementById('critChance').value) || 0;
            const currentCritDamage = parseFloat(document.getElementById('critDamage').value) || 0;
            const currentReAttackChance = parseFloat(document.getElementById('reAttackChance').value) || 0;
            
            console.log("--- compareUpgrades Debug --- ");
            console.log("读取到的克隆人数量:", cloneCount);
            console.log("读取到的暴击几率:", currentCritChance);
            console.log("读取到的暴击伤害:", currentCritDamage);
            console.log("读取到的双重射击:", currentReAttackChance);
            
            // 先保存当前输入框的值
            const critChanceOriginal = document.getElementById('critChance').value;
            const critDamageOriginal = document.getElementById('critDamage').value;
            const reAttackChanceOriginal = document.getElementById('reAttackChance').value;
            
            // 计算各项单次升级(+1%)的值和成本
            const critChanceUpgrade = getSingleUpgrade(currentCritChance, cloneCount);
            // 暴击伤害的成本计算（不需要减去基础值130%，因为输入框已经是纯增益值）
            const critDamageActual = currentCritDamage; // 不再减去基础值，因为输入框值就是增益部分
            const critDamageNextValue = Number((critDamageActual + 1.0).toFixed(1));
            const critDamageCost = sumExponentialRange(critDamageActual, critDamageNextValue) * cloneCount;
            const critDamageUpgrade = { 
                maxValue: critDamageNextValue, // 不再加回基础值，因为输入框值就是增益部分
                cost: critDamageCost 
            };
            const reAttackChanceUpgrade = getSingleUpgrade(currentReAttackChance, cloneCount);
            
            console.log("计算出的暴击几率升级成本 (已乘克隆数):", critChanceUpgrade.cost);
            console.log("计算出的暴击伤害升级成本 (已乘克隆数):", critDamageUpgrade.cost);
            console.log("计算出的双重射击升级成本 (已乘克隆数):", reAttackChanceUpgrade.cost);
            
            // 计算新增克隆人
            const newCloneCount = cloneCount + 1;
            const cloneCost = clonePrice;
            
            // 如果升级值和当前值相同则跳过模拟
            let critChanceResult = { currentWinRate: 0, newWinRate: 0 };
            let critDamageResult = { currentWinRate: 0, newWinRate: 0 };
            let reAttackChanceResult = { currentWinRate: 0, newWinRate: 0 };
            
            // 获取基础胜率
            document.getElementById('critChance').value = currentCritChance;
            document.getElementById('critDamage').value = currentCritDamage;
            document.getElementById('reAttackChance').value = currentReAttackChance;
            const baseParams = getParamsForLevel(parseInt(document.getElementById('enemyLevel').value));
            const baseWinRate = await new Promise((resolve) => {
                worker.onmessage = function(e) {
                    resolve((e.data.winCount / simCount) * 100);
                };
                worker.postMessage({ params: baseParams, simCount });
            });
            
            // 模拟单次升级后结果
            // 暴击几率
            document.getElementById('critChance').value = critChanceUpgrade.maxValue;
            const critChanceParams = getParamsForLevel(parseInt(document.getElementById('enemyLevel').value));
            const critChanceWinRate = await new Promise((resolve) => {
                worker.onmessage = function(e) {
                    resolve((e.data.winCount / simCount) * 100);
                };
                worker.postMessage({ params: critChanceParams, simCount });
            });
            critChanceResult = { currentWinRate: baseWinRate, newWinRate: critChanceWinRate };
            document.getElementById('critChance').value = currentCritChance;
            
            // 暴击伤害
            document.getElementById('critDamage').value = critDamageUpgrade.maxValue;
            const critDamageParams = getParamsForLevel(parseInt(document.getElementById('enemyLevel').value));
            const critDamageWinRate = await new Promise((resolve) => {
                worker.onmessage = function(e) {
                    resolve((e.data.winCount / simCount) * 100);
                };
                worker.postMessage({ params: critDamageParams, simCount });
            });
            critDamageResult = { currentWinRate: baseWinRate, newWinRate: critDamageWinRate };
            document.getElementById('critDamage').value = currentCritDamage;
            
            // 双重射击
            document.getElementById('reAttackChance').value = reAttackChanceUpgrade.maxValue;
            const reAttackParams = getParamsForLevel(parseInt(document.getElementById('enemyLevel').value));
            const reAttackWinRate = await new Promise((resolve) => {
                worker.onmessage = function(e) {
                    resolve((e.data.winCount / simCount) * 100);
                };
                worker.postMessage({ params: reAttackParams, simCount });
            });
            reAttackChanceResult = { currentWinRate: baseWinRate, newWinRate: reAttackWinRate };
            document.getElementById('reAttackChance').value = currentReAttackChance;
            
            // 评估新增克隆人的胜率变化
            let newCloneWinRate = baseWinRate;
            const originalCloneCount = document.getElementById('cloneCount').value;
            document.getElementById('cloneCount').value = newCloneCount;
            updateCloneStats();
            const newCloneParams = getParamsForLevel(parseInt(document.getElementById('enemyLevel').value));
            newCloneWinRate = await new Promise((resolve) => {
                worker.onmessage = function(e) {
                    resolve((e.data.winCount / simCount) * 100);
                };
                worker.postMessage({ params: newCloneParams, simCount });
            });
            document.getElementById('cloneCount').value = originalCloneCount;
            updateCloneStats();
            
            // 计算投资回报率 (胜率提升/成本)
            const critChanceROI = critChanceUpgrade.cost > 0 ? 
                (critChanceResult.newWinRate - critChanceResult.currentWinRate) / critChanceUpgrade.cost * 1000000 : 0;
            
            const critDamageROI = critDamageUpgrade.cost > 0 ? 
                (critDamageResult.newWinRate - critDamageResult.currentWinRate) / critDamageUpgrade.cost * 1000000 : 0;
            
            const reAttackChanceROI = reAttackChanceUpgrade.cost > 0 ? 
                (reAttackChanceResult.newWinRate - reAttackChanceResult.currentWinRate) / reAttackChanceUpgrade.cost * 1000000 : 0;
            
            const newCloneROI = cloneCost > 0 ? 
                (newCloneWinRate - baseWinRate) / cloneCost * 1000000 : 0;
            
            // 恢复所有原始值
            document.getElementById('critChance').value = critChanceOriginal;
            document.getElementById('critDamage').value = critDamageOriginal;
            document.getElementById('reAttackChance').value = reAttackChanceOriginal;
            
            // 找出最佳投资选项
            const options = [
                { name: '暴击几率', roi: critChanceROI },
                { name: '暴击伤害', roi: critDamageROI },
                { name: '双重射击', roi: reAttackChanceROI },
                { name: '新增克隆人', roi: newCloneROI }
            ];
            
            // 按ROI排序
            options.sort((a, b) => b.roi - a.roi);
            
            // 显示结果
            let resultHTML = '<h2>升级收益比较结果</h2>';
            resultHTML += '<table border="1"><tr><th>升级选项</th><th>当前值</th><th>升级后</th><th>成本 (货币)</th><th>胜率变化</th><th>投资回报率 (百万)</th></tr>';
            
            resultHTML += `<tr><td>暴击几率</td><td>${currentCritChance.toFixed(1)}%</td><td>${critChanceUpgrade.maxValue.toFixed(1)}%</td><td>${critChanceUpgrade.cost.toFixed(0)}</td>
                           <td>${(critChanceResult.newWinRate - critChanceResult.currentWinRate).toFixed(2)}%</td><td>${critChanceROI.toFixed(4)}</td></tr>`;
            
            resultHTML += `<tr><td>暴击伤害</td><td>${currentCritDamage.toFixed(1)}%</td><td>${critDamageUpgrade.maxValue.toFixed(1)}%</td><td>${critDamageUpgrade.cost.toFixed(0)}</td>
                           <td>${(critDamageResult.newWinRate - critDamageResult.currentWinRate).toFixed(2)}%</td><td>${critDamageROI.toFixed(4)}</td></tr>`;
            
            resultHTML += `<tr><td>双重射击</td><td>${currentReAttackChance.toFixed(1)}%</td><td>${reAttackChanceUpgrade.maxValue.toFixed(1)}%</td><td>${reAttackChanceUpgrade.cost.toFixed(0)}</td>
                           <td>${(reAttackChanceResult.newWinRate - reAttackChanceResult.currentWinRate).toFixed(2)}%</td><td>${reAttackChanceROI.toFixed(4)}</td></tr>`;
            
            resultHTML += `<tr><td>新增克隆人</td><td>${cloneCount}</td><td>${newCloneCount}</td><td>${cloneCost.toFixed(0)}</td>
                           <td>${(newCloneWinRate - baseWinRate).toFixed(2)}%</td><td>${newCloneROI.toFixed(4)}</td></tr>`;
            
            resultHTML += '</table>';
            resultHTML += '<p>注意：成本已乘以当前克隆人数量 ' + cloneCount + '</p>';
            resultHTML += `<h3>最佳投资选项</h3><p>根据当前分析，<strong>${options[0].name}</strong>的投资回报率最高，建议优先升级此项。</p>`;
            
            document.getElementById('result').innerHTML = resultHTML;
        }

        // 控制收益比较分析面板的显示/隐藏
        function toggleAnalysisPanel() {
            const hideAnalysis = document.getElementById('hideAnalysis').checked;
            document.getElementById('analysisPanel').style.display = hideAnalysis ? 'none' : 'block';
            localStorage.setItem('hideAnalysis', hideAnalysis);
        }
    </script>
</body>
</html>